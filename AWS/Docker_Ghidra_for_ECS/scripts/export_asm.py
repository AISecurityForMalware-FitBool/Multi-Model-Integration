# -*- coding: utf-8 -*-
# export_asm.py — Ghidra Jython script
# Exports each EXE into an .asm file under /opt/out (uploaded to S3 by run_one.sh)

import os

def b2hex(b):
    return "{:02X}".format((b + 256) % 256)

def main():
    # Output folder → Fargate 내부 결과 경로
    out_dir = "/opt/out"
    if not os.path.isdir(out_dir):
        os.makedirs(out_dir)

    prog = currentProgram
    analyzeAll(prog)

    listing = prog.getListing()
    fm = prog.getFunctionManager()

    # Generate output file name from program name (sample.exe → sample.asm)
    base = os.path.splitext(prog.getName())[0]
    safe = base.replace("/", "_").replace("\\", "_")
    out_path = os.path.join(out_dir, safe + ".asm")

    with open(out_path, "w") as f:
        f.write("; Program : {}\n".format(prog.getName()))
        f.write("; Lang    : {}\n".format(prog.getLanguage().getLanguageDescription().getLanguageID()))
        f.write("; AddrSz  : {}\n".format(prog.getDefaultPointerSize()))
        f.write("; --- auto-generated by export_asm.py ---\n\n")

        cur_func = None
        it = listing.getInstructions(True)
        while it.hasNext():
            ins = it.next()
            addr = ins.getMinAddress()
            func = fm.getFunctionContaining(addr)
            if func and func != cur_func:
                cur_func = func
                f.write("\n; ===== Function {} @ {} =====\n".format(func.getName(), func.getEntryPoint()))

            bs = ins.getBytes()
            byte_str = "" if bs is None else " ".join(b2hex(b) for b in bs)

            op_parts = []
            for i in range(ins.getNumOperands()):
                op_parts.append(ins.getDefaultOperandRepresentation(i))
            ops = ", ".join(op_parts)

            line = "{}: {:<24} {} {}\n".format(addr, byte_str, ins.getMnemonicString(), ops)
            f.write(line)

    print("[+] Wrote assembly listing -> {}".format(out_path))

main()
